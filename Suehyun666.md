# 1주차 보고서

## 미션 구현 과정에서 학습한 내용

- **객체 지향 설계의 중요성**: 로또 게임을 구현하면서 각 클래스가 명확한 책임을 가지도록 설계하는 것의 중요성을 배웠습니다. `Lotto`, `LottoTicket`, `LottoResult` 등의 클래스들이 각자의 역할을 수행하도록 설계했습니다.

- **유효성 검증 분리**: 사용자 입력에 대한 유효성 검증(`LottoValidator`)과 도메인 객체의 불변식 검증(각 클래스 내부)을 분리하여 처리하는 방법을 학습했습니다. 이를 통해 책임 분리와 코드 재사용성을 높일 수 있었습니다.

- **단순한 메서드의 중요성**: 가장 쉽고 단순하게 하나의 기능을 수행하는 메서드로 분리하여 가독성을 높이는 법을 연습했습니다.

## 고민했던 점

- **클래스 분리와 책임 할당**: `Lotto`와 `LottoTicket` 두 클래스의 역할 구분이 모호하다고 느꼈습니다. 단순히 위임 패턴만 적용되어 있어 불필요한 복잡성이 생기는 것이 아닌지 고민했습니다. 하나의 클래스로 통합하거나, 각 클래스의 역할을 더 명확히 구분하는 방안을 고려했습니다.

- **의존성 주입 문제**: 그동안은 의존성을 주입하면 오히려 결합도가 높아지는 것 아닌가 생각해왔는데, 이번에 의존성을 다시 공부하면서 그 이유를 깨달았습니다. 하지만 아직도 적용하는게 어렵습니다. 

- **과도한 정적 클래스 사용**: 이펙티브 자바에서 배운 것을 활용하고자 프로그램 내 간단한 로직은 static 메소드로 구현하다보니 객체지향이 아닌 절차지향적 접근에 가까워졌던 것 같습니다.


## 아쉬운 점

- **테스트 하기 좋게 만들기**: 테스트를 하는 이유가 거대한 프로그램에서 잘 동작하는지 확인하기 위해서인데 현재 구조는 이에 적합하지 않은 것 같습니다

- **인터페이스의 부족**: 객체지향의 꽃인 확장성, 유지보수성을 높여주는 인터페이스를 너무 적게 사용했던 것 같습니다. LottoGenerator 인터페이스 외에는 추상화를 위한 인터페이스 활용이 부족했습니다. 앞으로는 확장성을 더 고려하면서 개발해야겠습니다.

## Effective Java에서 배운 내용

- **아이템 1. 생성자 대신 정적 팩토리 메서드를 고려하라**: 처음에는 모든 클래스를 단순하게 생성했지만, 유틸리티 클래스의 생성자에 대해 고민하고 있었습니다. 이 부분을 읽고 의미를 명확히 전달할 수 있는 정적 팩토리 메서드(`LottoTicket.createRandom()`, `LottoTicket.fromNumbers()` 등)를 활용할 수 있음을 배웠습니다. 이를 통해 코드의 가독성과 의도를 명확히 할 수 있었습니다.

- **아이템 2. 생성자에 매개변수가 많다면 빌더를 고려하라**: 현재 코드에서는 생성자 매개변수가 많은 클래스가 없어 빌더 패턴이 필요하지 않았습니다. 

- **아이템 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라**: `LottoRank` enum을 사용하여 로또 등수를 표현했습니다. enum을 통해 타입 안전성을 보장하고 싱글턴 인스턴스를 효과적으로 관리할 수 있었습니다.

- **아이템 4. 인스턴스화를 막으려거든 private 생성자를 사용하라**: 유틸리티 클래스들(`LottoValidator`, `TicketValidator` 등)에서 private 생성자와 AssertionError를 사용해 인스턴스화를 막았습니다. 이를 통해 정적 메서드만 제공하는 클래스의 의도를 명확히 할 수 있었습니다.

- **아이템 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라**: `GameManager`가 `InputView`, `OutputView`, `LottoGenerator`를 생성자를 통해 주입받도록 설계했습니다. 하지만 `GameManager`에 책임이 너무 많아 어떻게 분리할지 고민 중입니다. 의존성 주입을 통해 코드의 유연성과 테스트 용이성을 높일 수 있음을 배웠습니다.

- **아이템 6. 불필요한 객체 생성을 피하라**: 불변 객체나 재사용 가능한 객체의 경우 매번 새로 생성하기보다 재사용하는 방식을 고려해야 함을 배웠습니다. 특히 반복적으로 사용되는 객체는 캐싱하거나 정적 팩토리 메서드를 통해 인스턴스를 재활용할 수 있다는 것을 배웠습니다.

- **아이템 7. 다 쓴 객체 참조를 해제하라**: 특별히 큰 메모리를 사용하는 컬렉션이나 캐시가 없어 명시적 참조 해제가 필요한 부분은 없었습니다. 그러나 자바를 오랫동안 사용해왔기에 메모리 관리의 중요성을 간과했던 점을 깨달았습니다. 향후 대용량 데이터를 다룰 때는 이 원칙을 명심해야겠습니다.

- **아이템 8. finalizer와 cleaner 사용을 피하라**: finalizer나 cleaner를 사용하지 않았습니다. 이러한 메커니즘은 예측할 수 없고 위험하므로 피해야 한다는 점을 배웠습니다.

- **아이템 9. try-finally보다는 try-with-resources를 사용하라**: 명시적인 리소스 관리가 필요한 부분이 많지 않았습니다. 하지만 자원을 안전하게 닫아야 하는 경우, try-with-resources를 사용하면 코드가 더 간결해지고 자원 누수의 위험을 줄일 수 있음을 배웠습니다. 예를 들어, 파일 입출력이나 네트워크 연결 같은 자원을 다룰 때 이 방식이 매우 유용할 것 같습니다.